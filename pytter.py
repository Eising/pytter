"""
Pytter : A really simple library for generating reverse DNS zones
Written by Allan Eising <eising@nordu.net>

See README file for more info

"""
from IPy import IP
import re
import time


__version__ = '1.0'


class Pytter(object):
    rdns = dict()
    serialnumber = time.strftime("%Y%m%d00")    # Initialize a default serial
    aggregate_v4 = 24
    aggregate_v6 = 48

    def __init__(self, primary_server, email, nameservers=[],
                 default_ttl=86400, refresh=14400, retry=1800, expire=1209600,
                 minimum_ttl=3600, soa_ttl=1800):

        # Validate arguments:
        # Ensure trailing dot to primary_server and email
        if (primary_server.endswith(".")):
            self._primary_server = primary_server
        else:
            self._primary_server = "{}.".format(primary_server)

        # Email
        if (email.endswith(".")):
            self._email = email
        else:
            self._email = "{}.".format(email)

        # Iterate over nameservers to ensure this too
        self._nameservers = [self._primary_server]
        if (isinstance(nameservers, list)):
            for ns in nameservers:
                if (ns.endswith(".")):
                    self._nameservers.append(ns)
                else:
                    self._nameservers.append("{}.".format(ns))
        else:
            if (nameservers.endswith(".")):
                self._nameservers.append(nameservers)
            else:
                self._nameservers.append("{}.".format(nameservers))

        # Do basic validation on remaining arguments
        # default_ttl
        if (isinstance(default_ttl, (int, long))):
            self._default_ttl = default_ttl
        else:
            raise ValueError("default_ttl must be a number")
        # refresh
        if (isinstance(refresh, (int, long))):
            self._refresh = refresh
        else:
            raise ValueError("refresh must be a number")

        # retry
        if (isinstance(retry, (int, long))):
            self._retry = retry
        else:
            raise ValueError("retry must be a number")

        # expire
        if (isinstance(expire, (int, long))):
            self._expire = expire
        else:
            raise ValueError("expire must be a number")

        # minimum_ttl
        if (isinstance(minimum_ttl, (int, long))):
            self._minimum_ttl = minimum_ttl
        else:
            raise ValueError("minimum_ttl must be a number")

        # soa_ttl
        if (isinstance(soa_ttl, (int, long))):
            self._soa_ttl = soa_ttl
        else:
            raise ValueError("soa_ttl must be a number")

    def add_ip(self, address, dtype, dvalue):
        ip = IP(address)
        reverse_name = self.get_zone_name(address)

        if(reverse_name not in self.rdns):
            self.rdns[reverse_name] = dict()
        if(ip not in self.rdns[reverse_name]):
            self.rdns[reverse_name][ip] = dict()
        self.rdns[reverse_name][ip][dtype] = dvalue

    def add_reverse(self, address, ptr):
        self.add_ip(address, "PTR", ptr)

    def get_zone_name(self, address):
        ip = IP(address)
        v4size = self.aggregate_v4
        v6size = self.aggregate_v6
        if (ip.version() == 4):
            reverse_name = re.sub(
                    r'\.$', '', ip.make_net(v4size).reverseName())
        elif (ip.version() == 6):
            reverse_name = re.sub(
                    r'\.$', '', ip.make_net(v6size).reverseName())
        return reverse_name

    def dump_zone(self, fqdn):
        zone = "; {} - generated by pytter.\n".format(fqdn)
        zone += self.__generate_zone_header()
        for ip, data in self.rdns[fqdn].iteritems():
            for dtype, dvalue in data.iteritems():
                zone += self.__generate_record(ip, dtype, dvalue)
        return zone

    def dump_zones(self, directory=None):
        if (directory is not None):
            for fqdn in self.rdns.iterkeys():
                filename = "{}/{}".format(directory, fqdn)
                f = open(filename, "w")
                f.write(self.dump_zone(fqdn))
                f.close()
        else:
            for fqdn in self.rdns.iterkeys():
                print self.dump_zone(fqdn)

    # Private methods
    def __generate_zone_header(self):
        serialnumber = self.serialnumber
        headers = "$TTL {}\n".format(self._default_ttl)
        headers += "@ {:<5} {:<8} {:<8} {:<8} {:<8} (\n".format(
                self._soa_ttl, "IN", "SOA",
                self._primary_server, self._email)
        headers += "{:>42} ; {}\n".format(serialnumber, "Serial number")
        headers += "{:>42} ; {}\n".format(self._refresh, "Refresh")
        headers += "{:>42} ; {}\n".format(self._retry, "Retry")
        headers += "{:>42} ; {}\n".format(self._expire, "Expire")
        headers += "{:>42} {}; {}\n".format(
                self._minimum_ttl, ")", "Minimum TTL")
        for ns in self._nameservers:
            headers += "{:<2}{:<5} {:<8} {:<8} {:<8}\n".format(
                    "", "", "", "NS", ns)

        return headers

    def __generate_record(self, ip, dtype, dvalue):
        if (ip.version() == 4):
            record = "{:<29}{:<8}{:<8}{}\n".format(
                    ip.reverseName(), "", dtype, dvalue)
        elif (ip.version() == 6):
            record = "{:<73}{:<8}{:<8}{}\n".format(
                    ip.reverseName(), "", dtype, dvalue)
        return record
